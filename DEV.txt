
Development commands, just for reference.
Debugging C++ modules, etc.

Simple integration test.
LD_PRELOAD="/lib/libSegFault.so /home/instance/study/SS2019BA/schmoll/impl/release/testthis.cpython-37m-x86_64-linux-gnu.so" gdb --args python3 -c "import runner"

Profile the code.
LD_PRELOAD="/lib/libSegFault.so /home/instance/study/SS2019BA/schmoll/impl/release/testthis.cpython-37m-x86_64-linux-gnu.so" python3 -c "import mdp_profile"

See the chart. Is the path calculated correct?
LD_PRELOAD="/lib/libSegFault.so /home/instance/study/SS2019BA/schmoll/impl/release/testthis.cpython-37m-x86_64-linux-gnu.so" python3 -c "import mdp_draw"

// -pg flag is for gprof.
g++ -g -pg -pthread -fwrapv -O3 -mtune=generic -O3 -pipe -fno-plt  -I. testthis.cpp -o testthis.o
./testthis.o
gprof testthis.o > a.txt

There's two files hashmap1.txt and hashmap2.txt to compare std::unordered_map vs sparsepp which is based on google sparsehash.
They were generated by gprof.
Was good enough, so after looking at their writeup I went with dense_hash_map since its access times are godlike.
cereal serialization was used to do these profilings (I saved Python input once to be able to load it all the time later).

Includes mdp_PYTHON_INTERACTION.html to show how much Python interaction mdp had before I started with this whole C++ module thing.

It is vital to set the MDP type.
See mdp_draw.pyx.

When wrapping a c++ class, dont forget to implement the destructor in the cpp file, else you cant load the library with LD_PRELOAD.
https://stackoverflow.com/questions/45655839/undefined-symbols-when-trying-to-use-cython-extensions

Python objects that get initialized in a function and get passed to the C++ module get garbage collected after Python leaves the function.
So after a short time for example maps that were passed to the D* Lite C++ module became garbage.
These type of objects need to be declared in the pxd header file of the Python wrapper.

